/*
 * Copyright (C) 2023 Linnea Gr√§f
 *
 * This file is part of NotEnoughUpdates.
 *
 * NotEnoughUpdates is free software: you can redistribute it
 * and/or modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 *
 * NotEnoughUpdates is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with NotEnoughUpdates. If not, see <https://www.gnu.org/licenses/>.
 */

package io.github.moulberry.notenoughupdates.autosubscribe

import com.google.devtools.ksp.getDeclaredFunctions
import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.addOriginatingKSFile
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import java.util.function.Consumer

internal class NEUAutoSymbolProcessor(val codeGenerator: CodeGenerator, val logger: KSPLogger) : SymbolProcessor {
    fun collectSubscribers(elements: Sequence<KSAnnotated>): List<NEUEventSubscriber> = buildList {
        for (element in elements) {
            if (element !is KSClassDeclaration) {
                logger.error("@NEUAutoSubscribe is only valid on class or object declarations", element)
                continue
            }
            val name = element.qualifiedName
            if (name == null) {
                logger.error("@NEUAutoSubscribe could not find name", element)
                continue
            }
            when (element.classKind) {
                ClassKind.CLASS -> {
                    val instanceGetter = element.getDeclaredFunctions().find {
                        it.simpleName.asString() == "getInstance"
                    }
                    val instanceVariable = element.getDeclaredProperties().find {
                        it.simpleName.asString() == "INSTANCE"
                    }
                    if (instanceGetter != null) {
                        val returnType = instanceGetter.returnType
                        // TODO: typechecking
                        add(NEUEventSubscriber(InvocationKind.GET_INSTANCE, element))
                    } else if (instanceVariable != null) {
                        // TODO: typechecking
                        add(NEUEventSubscriber(InvocationKind.ACCESS_INSTANCE, element))
                    } else {
                        // TODO: typechecking
                        add(NEUEventSubscriber(InvocationKind.DEFAULT_CONSTRUCTOR, element))
                    }
                }

                ClassKind.OBJECT -> {
                    add(NEUEventSubscriber(InvocationKind.OBJECT_INSTANCE, element))
                }

                else -> {
                    logger.error(
                        "@NEUAutoSubscribe is only valid on classes and objects, not on ${element.classKind}",
                        element
                    )
                    continue
                }
            }
        }

    }

    val subscribers = mutableListOf<NEUEventSubscriber>()
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val candidates = resolver.getSymbolsWithAnnotation(NEUAutoSubscribe::class.qualifiedName!!)
        subscribers.addAll(collectSubscribers(candidates))
        return emptyList()
    }

    override fun finish() {
        if (subscribers.isEmpty()) return
        FileSpec.builder("io.github.moulberry.notenoughupdates.autosubscribe", "AutoLoad")
            .addFileComment("@generated by ${NEUAutoSymbolProcessor::class.simpleName}")
            .addType(
                TypeSpec.objectBuilder("AutoLoad")
                    .addFunction(
                        FunSpec.builder("provide")
                            .addParameter("consumer", Consumer::class.parameterizedBy(Any::class))
                            .apply {
                                subscribers.sortedBy { it.declaration.simpleName.asString() }.forEach { (invocationKind, declaration) ->
                                    when (invocationKind) {
                                        InvocationKind.GET_INSTANCE -> addStatement(
                                            "consumer.accept(%T.getInstance())",
                                            declaration.toClassName()
                                        )

                                        InvocationKind.OBJECT_INSTANCE -> addStatement(
                                            "consumer.accept(%T)",
                                            declaration.toClassName()
                                        )

                                        InvocationKind.DEFAULT_CONSTRUCTOR -> addStatement(
                                            "consumer.accept(%T())",
                                            declaration.toClassName()
                                        )

                                        InvocationKind.ACCESS_INSTANCE -> addStatement(
                                            "consumer.accept(%T.INSTANCE)",
                                            declaration.toClassName()
                                        )
                                    }
                                    declaration.containingFile?.let {
                                        addOriginatingKSFile(it)
                                    }
                                }
                            }
                            .build()
                    )
                    .build()
            )
            .build()
            .writeTo(codeGenerator, aggregating = true)
    }
}
